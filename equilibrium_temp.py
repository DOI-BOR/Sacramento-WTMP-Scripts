import datetime as dt
import math

# TODO: hardcoded lat/lon sould be variable

zero_K = 273.15
Tk = zero_K
stefan_boltz_const = 5.67e-8
lw_emissivity_water = 0.97
reference_density = 1000.
wind_a = 2.8e-9
wind_b = 1.2e-9
Magnus_a = 6.1078
Magnus_b = 17.27
Magnus_c = 237.7
Cb = 0.61

def bisection_solve(fTe_min, a, b, H1, uw, Ta_in, td, sat_vp_ta, tol=1e-2, max_iter=1000):
    
    fa = fTe_min(a, H1, uw, Ta_in, td, sat_vp_ta)
    fb = fTe_min(b, H1, uw, Ta_in, td, sat_vp_ta)

    # if fa * fb >= 0:
    #    raise ValueError("Bisection method requires signs of f(a) and f(b) to be opposite")

    iter_count = 0
    while (b - a) / 2.0 > tol:
        c = (a + b) / 2.0
        # protect against divide-by-zero during iteration
        if (c-td) == 0.0:
            c += tol
        fc = fTe_min(c, H1, uw, Ta_in, td, sat_vp_ta)

        if fc == 0 or (b - a) / 2.0 < tol:
            return c  # Root found
        #print('BC:',a,b,c)
        iter_count += 1
        if iter_count > max_iter:
            raise ValueError("bisection_solve: Maximum iterations exceeded")

        if fa * fc < 0.0:
            b = c
            fb = fc
        else:
            a = c
            fa = fc

    return (a + b) / 2.0  # Returning the middle of the final interval


def newton_raphson_solve(f, df, x0, H1, uw, Ta_in, Td, sat_vp_ta, tol=1e-2, max_iter=1000):
    iter_count = 0
    x_old = x0
    while iter_count < max_iter:
        fx_old = f(x_old, H1, uw, Ta_in, Td, sat_vp_ta)
        dfx_old = df(x_old, H1, uw, Ta_in, Td, sat_vp_ta)

        if abs(dfx_old) < tol:
            raise ValueError("Derivative near zero")

        x_new = x_old - fx_old / dfx_old
        #print('NR:',x0,x_new,x_old,fx_old,dfx_old)

        if abs(x_new - x_old) < tol:
            return x_new  # Root found

        x_old = x_new
        iter_count += 1

    # print(x0, x_new, x_old, ' Ta_in: ', Ta_in, ' Td: ', Td, ' sat_vp_ta: ', sat_vp_ta)
    raise ValueError("newton_raphson_solve: Maximum iterations exceeded")


def get_decimal_day_of_year(tin):
    foy = dt.datetime(tin.year, 1, 1, 0, 0, 0)
    ddoy = (tin - foy).total_seconds() / 86400. + 1.
    return ddoy


def solar_alt_angle(tin):
    latitude = 38.1
    longitude = 121.8
    time_zone_longitude = 120.

    delta = (longitude - time_zone_longitude) / 15.
    doy = get_decimal_day_of_year(tin)

    solar_decl = 0.4092 * math.cos(2. * math.pi / 365. * (172. - doy))
    t1 = math.sin(solar_decl) * math.sin(latitude * math.pi / 180.)
    t2 = math.cos(solar_decl) * math.cos(latitude * math.pi / 180.)
    hr = (doy - math.floor(doy)) * 24.
    hr_angle = math.pi * (hr - delta - 12.) / 12.
    sin_solar_alt = t1 + t2 * math.cos(hr_angle)
    solar_alt_angle = math.asin(sin_solar_alt) * 180. / math.pi
    return solar_alt_angle


def sw_water_reflectance(tin, cloud_in):
    alt_angle = solar_alt_angle(tin)
    if alt_angle <= 0.:
        return 1.
    else:
        if cloud_in > 0.95:
            acoef = 0.33
            bcoef = -0.45
        elif cloud_in > 0.55:
            acoef = 0.95
            bcoef = -0.75
        elif cloud_in > 0.05:
            acoef = 2.20
            bcoef = -0.97
        else:
            acoef = 1.18
            bcoef = -0.77
        water_sfc_reflectance = acoef * alt_angle ** bcoef
        water_sfc_reflectance = min(water_sfc_reflectance, 1.)
        return water_sfc_reflectance


def heat_flux_surface_longwave_down(air_temp_in, cloud_in):
    sfc_reflect_fract = 0.03
    cloud_cover_fract_coef = 0.17
    con1 = 0.937e-5
    Tkel = air_temp_in + zero_K
    emissivity_air = con1 * (1. + cloud_cover_fract_coef * cloud_in ** 2) * Tkel ** 2
    hlwd = emissivity_air * stefan_boltz_const * (1. - sfc_reflect_fract) * Tkel ** 4
    return hlwd


def latent_heat_vaporization(temp_in):
    return 1000. * (2499. - 2.36 * temp_in)


def sat_water_vapor_pres(temp_in):
    # Magnes-Tetens formula
    return Magnus_a * math.exp(Magnus_b * temp_in / (temp_in + Magnus_c))


def fTe(Te, H1, uw, Ta_in, Td, sat_vp_ta):
    '''Calculation of fTe with only Te-dependent terms'''
    Lw = latent_heat_vaporization(Te)
    sat_vp_te = sat_water_vapor_pres(Te)
    beta = (sat_vp_te - sat_vp_ta) / (Te - Td)
    return H1 - lw_emissivity_water * stefan_boltz_const * (Tk ** 4 + 4. * Tk ** 3 * Te + 6. * Tk ** 2 * Te ** 2) + \
        reference_density * Lw * (wind_a + wind_b * uw) * ((Cb * Ta_in + beta * Td) - (Cb + beta) * Te)


def dfTe_dTe(Te, H1, uw, Ta_in, Td, sat_vp_ta):
    '''derivative of fTe, generated by Chat GPT 4'''

    Lw = 1000. * (2499. - 2.36 * Te)
    sat_vp_te = Magnus_a * math.exp(Magnus_b * Te / (Te + Magnus_c))

    # Derivatives
    dLw_dTe = -1000. * 2.36
    dsat_vp_te_dTe = (Magnus_a * Magnus_b * math.exp(Magnus_b * Te / (Te + Magnus_c))) / (Te + Magnus_c) - \
                     (Magnus_a * Magnus_b * Te * math.exp(Magnus_b * Te / (Te + Magnus_c))) / (Te + Magnus_c) ** 2
    dbeta_dTe = (dsat_vp_te_dTe * (Te - Td) - (sat_vp_te - sat_vp_ta)) / (Te - Td) ** 2

    dTe_term = - 4.0 * lw_emissivity_water * stefan_boltz_const * Tk ** 3 - 12.0 * lw_emissivity_water * stefan_boltz_const * Tk ** 2 * Te
    Lw_term = reference_density * (wind_a + wind_b * uw) * ((Cb * Ta_in + (sat_vp_te - sat_vp_ta) / (Te - Td) * Td) - (
            Cb + (sat_vp_te - sat_vp_ta) / (Te - Td)) * Te)
    beta_term = reference_density * Lw * (wind_a + wind_b * uw) * (-(Cb + (sat_vp_te - sat_vp_ta) / (Te - Td)))

    return dTe_term + Lw_term + beta_term + reference_density * dLw_dTe * (wind_a + wind_b * uw) * (
            (Cb * Ta_in + (sat_vp_te - sat_vp_ta) / (Te - Td) * Td) - (
            Cb + (sat_vp_te - sat_vp_ta) / (Te - Td)) * Te) + reference_density * Lw * (
            wind_a + wind_b * uw) * dbeta_dTe * Td


def fTe_min(Te, H1, uw, Ta_in, Td, sat_vp_ta):
    return Te - fTe(Te, H1, uw, Ta_in, Td, sat_vp_ta)

def fTe_abs(Te, H1, uw, Ta_in, Td, sat_vp_ta):
    return abs(fTe(Te, H1, uw, Ta_in, Td, sat_vp_ta))


def equilibrium_temp(dtt1, at, cl, sr, ws, td, te_guess, type='nr'):
    reflectance = sw_water_reflectance(dtt1, cl)
    Hsw = sr * (1. - reflectance)
    HH = heat_flux_surface_longwave_down(at, cl)
    H1 = Hsw + HH
    sat_vp_ta = sat_water_vapor_pres(at)
    if type == 'nr':
        return newton_raphson_solve(fTe, dfTe_dTe, te_guess, H1, ws, at, td, sat_vp_ta, tol=1.0e-2, max_iter=1000)
    elif type == 'bs':
        return bisection_solve(fTe_min, -30.0, 55.0, H1, ws, at, td, sat_vp_ta, tol=1.0e-2, max_iter=1000)
    elif type == 'scipy':
       # Original equilibrium temp calc using scipy.optimize/minimize.  Can't use scipy in jython
       args = (H1, ws, at, td, sat_vp_ta)
       res = minimize(fTe_abs, x0=te_guess, args=args)
       return res.x
    else:
        raise ValueError('equilibrium_temp() - calculation type not known:', type)


def calc_equilibrium_temp(dtt, at, cl, sr, td, ws):
    '''adapted from numpy/scipy routine by Steve, Ben, Scott, which was generated from:
    "Stratification and heat transfer in lakes and reservoirs" chapter in "Hydrodynamics and Transport
    for Water Quality Modeling" by Martin and McCutcheon (pg. 373)

    dtt = list of datetime objects
    at = list of airtemps [C]
    cl = list of cloud cover fractions [0-1]
    sr = shortwave irradiance [W/m2]
    dp = dewpoint [C]
    ws = wind speed [m/s]
    '''
    nt = len(dtt)
    te = []

    for j in range(nt):

        print('Equilibrium step ',j,' of ',nt)
        if j == 0:
            x0 = at[j]
        else:
            x0 = te[j - 1]

        # The Newton-Raphson solver sometimes fails (when the derivitive goes big/non-linear) or produces a really bad
        # value.  We calulcate a secondary solution (which is sometimes inaccurate be over a degree, but usually is
        # within 0.2 degrees of the solution using scipy.optimize.minimize) and use it in those cases.
        te.append(-999)
        #print(dtt[j], at[j], cl[j], sr[j], ws[j], td[j])
        te_bs = equilibrium_temp(dtt[j], at[j], cl[j], sr[j], ws[j], td[j], x0, type='bs')
        try:
            te[j] = equilibrium_temp(dtt[j], at[j], cl[j], sr[j], ws[j], td[j], x0, type='nr')
        except:
            print(j, ' Newton-Raphson failure (convergence).  Using bisection-solution equilibrium temp')
            te[j] = te_bs
        print(te[j],te_bs)

        if abs(te[j] - te_bs) > 2.0:
            print(j, ' Newton-Raphson failure (bad value).  Using bisection-solution equilibrium temp')
            te[j] = te_bs

    return te


